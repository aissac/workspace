//@version=5
strategy("R.Jim Simons — Residual Momentum + Regime Detection", 
     overlay=false, 
     initial_capital=100000,
     default_qty_type=strategy.percent_of_equity,
     default_qty_value=10,
     commission_type=strategy.commission.percent,
     commission_value=0.06)

// ═════════════════════════════════════════════════════════════════════════════
// MEDALLION FUND STRATEGY #1: RESIDUAL MOMENTUM WITH REGIME DETECTION
// 
// Philosophy: Trade not the trend, but the deviation from trend that 
//            hasn't been arbitraged out yet. Stop when regimes shift.
//
// Author: R.Jim Simons (adapted for crypto)
// ═════════════════════════════════════════════════════════════════════════════

// === INPUTS ═════════════════════════════════════════════════════════════════

// Momentum parameters
lookback = input.int(20, "Momentum Lookback", minval=10, maxval=50, step=5)
volPeriod = input.int(20, "Volatility Period", minval=10, maxval=50)
regimePeriod = input.int(50, "Regime Detection Period", minval=30, maxval=100)

// Signal thresholds
entryThreshold = input.float(1.5, "Entry Threshold (σ)", minval=1.0, maxval=3.0, step=0.1)
exitThreshold = input.float(0.5, "Exit Threshold (σ)", minval=0.1, maxval=1.0, step=0.1)
regimeShiftThreshold = input.float(1.5, "Regime Shift Threshold", minval=0.5, maxval=3.0, step=0.1)

// Risk management
maxPositions = input.int(3, "Max Concurrent Positions", minval=1, maxval=10)
kellyFraction = input.float(0.25, "Kelly Fraction", minval=0.1, maxval=0.5, step=0.05)
costThreshold = input.float(0.002, "Cost Threshold (bps)", minval=0.001, maxval=0.01, step=0.001)

// Time filter (only trade during specific hours to avoid low liquidity)
tradingStart = input.int(8, "Trading Start Hour (UTC)", minval=0, maxval=23)
tradingEnd = input.int(20, "Trading End Hour (UTC)", minval=0, maxval=23)

// === INDICATORS ═════════════════════════════════════════════════════════════

// 1. Calculate residual returns (detrended)
// This is the core: price change minus expected change from trend
priceChange = close - close[1]
trendComponent = ta.sma(priceChange, lookback)
residual = priceChange - trendComponent

// 2. Volatility-adjusted momentum score (z-score of residuals)
currentVol = ta.stdev(close, volPeriod)
volAdjustedScore = residual / (currentVol + 0.0001)

// 3. Regime detection using correlation breakdown
// Compare short-term correlation to long-term correlation
// If they diverge significantly, regime shift is occurring
corrShort = ta.correlation(close, close[1], 10)
corrLong = ta.correlation(close, close[1], regimePeriod)
regimeScore = math.abs(corrShort - corrLong)
regimeStable = regimeScore < regimeShiftThreshold

// 4. Expected slippage estimation (higher vol = higher slippage)
expectedSlippage = (ta.atr(volPeriod) / close) * 0.1

// 5. Kelly position sizing input
// Win rate estimate based on current momentum strength
winRate = 0.55 + (math.abs(volAdjustedScore) / 10)  // Higher score = higher confidence
winRate := math.max(0.3, math.min(0.8, winRate))

// Kelly fraction calculation (simplified)
avgWin = 0.03  // Target 3% avg win
avgLoss = 0.015  // Stop at 1.5%
b = avgWin / avgLoss
kellyRaw = (winRate * (b + 1) - 1) / b
kellyPosition = math.max(0, kellyRaw * kellyFraction)

// === SIGNAL GENERATION ══════════════════════════════════════════════════════

// Entry conditions
// Long: High positive momentum in stable regime
// Short: High negative momentum in stable regime

hasPosition = strategy.position_size != 0
availableSlot = strategy.closedtrades < maxPositions

longCondition = volAdjustedScore > entryThreshold and regimeStable and not hasPosition and availableSlot
shortCondition = volAdjustedScore < -entryThreshold and regimeStable and not hasPosition and availableSlot

// Exit conditions
// Exit when momentum mean-reverts OR regime becomes unstable

exitLong = (volAdjustedScore < exitThreshold) or not regimeStable
exitShort = (volAdjustedScore > -exitThreshold) or not regimeStable

// Cost check - only trade if expected edge > costs
expectedEdge = math.abs(volAdjustedScore) / 10
shouldTrade = expectedEdge > costThreshold

// Time filter (avoid illiquid hours)
currentHour = hour(time, "UTC")
inTradingHours = currentHour >= tradingStart and currentHour < tradingEnd

// === EXECUTION ══════════════════════════════════════════════════════════════

// Long entry
if longCondition and shouldTrade and inTradingHours
    positionSize = kellyPosition * 100  // Convert to percentage of equity
    strategy.entry("Long", strategy.long, qty=positionSize)
    
    // Alert for webhook
    alert('{"strategy":"ResidualMomentum","action":"entry","direction":"long","symbol":"' + syminfo.ticker + '","price":' + str.tostring(close) + ',"score":' + str.tostring(volAdjustedScore) + ',"regime_stable":' + str.tostring(regimeStable) + ',"kelly":' + str.tostring(kellyPosition) + ',"timestamp":"' + str.tostring(time) + '"}', alert.freq_once_per_bar_close)

// Short entry  
if shortCondition and shouldTrade and inTradingHours
    positionSize = kellyPosition * 100
    strategy.entry("Short", strategy.short, qty=positionSize)
    
    alert('{"strategy":"ResidualMomentum","action":"entry","direction":"short","symbol":"' + syminfo.ticker + '","price":' + str.tostring(close) + ',"score":' + str.tostring(volAdjustedScore) + ',"regime_stable":' + str.tostring(regimeStable) + ',"kelly":' + str.tostring(kellyPosition) + ',"timestamp":"' + str.tostring(time) + '"}', alert.freq_once_per_bar_close)

// Exit long
if exitLong and strategy.position_size > 0
    strategy.close("Long", comment="Exit: Score<" + str.tostring(exitThreshold) + " or RegimeShift")

// Exit short
if exitShort and strategy.position_size < 0
    strategy.close("Short", comment="Exit: Score>-" + str.tostring(exitThreshold) + " or RegimeShift")

// === PLOTTING ═════════════════════════════════════════════════════════════════

// Main indicator
plot(volAdjustedScore, "Residual Momentum (Z-Score)", color=regimeStable ? color.white : color.orange, linewidth=2)

// Threshold lines
hline(entryThreshold, "Long Entry", color=color.teal, linestyle=hline.style_dashed)
hline(-entryThreshold, "Short Entry", color=color.red, linestyle=hline.style_dashed)
hline(exitThreshold, "Exit Long", color=color.teal, linestyle=hline.style_dotted)
hline(-exitThreshold, "Exit Short", color=color.red, linestyle=hline.style_dotted)
hline(0, "Zero Line", color=color.gray)

// Background coloring based on regime stability
regimeColor = not regimeStable ? color.new(color.red, 90) : 
              math.abs(volAdjustedScore) > entryThreshold ? color.new(color.white, 95) : na
bgcolor(regimeColor, title="Regime/Signal Status")

// Position markers
plotshape(longCondition, "Long Entry", shape.triangleup, location.bottom, color.teal, size=size.small)
plotshape(shortCondition, "Short Entry", shape.triangledown, location.top, color.red, size=size.small)

// === DASHBOARD DISPLAY ═════════════════════════════════════════════════════

// Table for key metrics
if barstate.islast
    var table dashboard = table.new(position.top_right, 2, 6, bgcolor=color.black, border_width=1, border_color=color.gray)
    
    table.cell(dashboard, 0, 0, "Regime Score", text_color=color.gray, text_size=size.tiny)
    table.cell(dashboard, 1, 0, str.tostring(regimeScore, "#.##"), text_color=regimeStable ? color.white : color.red, text_size=size.small)
    
    table.cell(dashboard, 0, 1, "Corr Short", text_color=color.gray, text_size=size.tiny)
    table.cell(dashboard, 1, 1, str.tostring(corrShort, "#.##"), text_color=color.white, text_size=size.small)
    
    table.cell(dashboard, 0, 2, "Corr Long", text_color=color.gray, text_size=size.tiny)
    table.cell(dashboard, 1, 2, str.tostring(corrLong, "#.##"), text_color=color.white, text_size=size.small)
    
    table.cell(dashboard, 0, 3, "Kelly Frac", text_color=color.gray, text_size=size.tiny)
    table.cell(dashboard, 1, 3, str.tostring(kellyPosition * 100, "#.") + "%", text_color=color.teal, text_size=size.small)
    
    table.cell(dashboard, 0, 4, "Est WinRate", text_color=color.gray, text_size=size.tiny)
    table.cell(dashboard, 1, 4, str.tostring(winRate * 100, "#.") + "%", text_color=color.teal, text_size=size.small)
    
    table.cell(dashboard, 0, 5, "Slippage", text_color=color.gray, text_size=size.tiny)
    table.cell(dashboard, 1, 5, str.tostring(expectedSlippage * 10000, "#.") + "bps", text_color=color.orange, text_size=size.small)

// ═════════════════════════════════════════════════════════════════════════════
// BACKTEST REQUIREMENTS (Dr. Simons' Rules):
// 
// Before going live:
// 1. 500+ trades over 2 years of data
// 2. Profit factor > 1.3
// 3. Win rate > 55% (but edge magnitude matters more)
// 4. Max drawdown < 15%
// 5. Positive expectancy (avg win * win_rate > avg_loss * loss_rate)
// 6. Regime stability > 80% of trading days
//
// If alpha decay slope turns negative for >20 consecutive trades: HALT
// ═════════════════════════════════════════════════════════════════════════════
